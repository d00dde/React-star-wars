--Жизненный цикл React-компонента--

Инициализация:
constructor (props) {   
	super(props);

	this.state = {
		option: props.option //установка начального состояния через передачу свойств
	}
}

componentWillMount () {   //вызывается перед тем, как компонент будет смонтирован
						//используется для получения данных, нужных для работы,
						//запросов на сервер, и т.п.
}

render () { //создат React-компонент, который помещается в виртуальный, а потом и в реальный DOM
		//не должен содержать "тяжелого" и асинхронного кода. 
}

componentDidMount () { //вызывается сразу после размещения компонента в DOM
		//здесь уже можно работать с фактическим DOM: вешать слушатели, получать данные, 
		//реальные размеры и положение в браузере и т.п.
}

Обновление:
Причиной обновления компонента является изменение его состояния, либо
состояния любого из его родителей (вызов setState(state))

componentWillReceiveProps (nextProps) { //вызывается при изменении состояния любого родителя (только родителя)
	//здесь доступны как текущие props, так и обновлнные nextProps
	//используется для проверки, изменились ли props и нужно ли менять 
	//состояние данного компонента
}

shouldComponentUpdate (nextProps, nextState) { //вызывается перед componentWillUpdate, содержит
											   //новые props и state. Тут разработчик может решить, нужно ли
											   //перестраивать компонент, исходя из сравнения старых и новых props и state
 return true;	//если этот метод вернёт true (или не реализован) то компонент будет пересторен
 				//если метод вернёт false, то выполнение методов обновления для компонента будет прекращено
}

В React есть специальный класс PureComponent. От него наследуются вместо {Component}
В нём реализован метод shouldComponentUpdate, в котором сравниваются ВСЕ props и state
и при изменении любого из свойств компонент обновляется. 

componentWillUpdate (nextProps, nextState) { //вызывается после изменения компонента (либо компонента, либо родителя)
		//используется для получения данных, необходимых для нового состояния
		//здесь в аргументах приходят новые props и state, а в свойствах пока старые
}

render () {}

componentDidUpdate (prevProps, prevState) { //вызывается после внесения изменений в фактический DOM
		//используется так же, как и componentDidMount(), но после изменения компонента
		//здесь в аргументах приходят старые props и state, а новые уже применены
}

Удаление компонента:

componentDidUnmount () { //вызывается при удалении компонента
		//используется для освобождения ресурсов, отписки от событий, и т.п. 

}

Ошибка в методах жизненного цикла.

componentDidCatch (error, info) { //Метод срабатывает при возникновении ошибки в методах 
																	//жизненного цикла компонента, либо его детей
																	//error - стандартный JS объект брошенной ошибки
																	//info - React объект со стеком React компонентов.
}

static getDerivedStateFromError(error) {
      // Обновление состояния, чтобы при последующей отрисовке показать аварийный UI.
      return { hasError: true };
}

--Паттерны React--

1. Передача функций в качестве аргументов. Таким образом можно вынести функционал
компонента наверх, тем самым обеспечив бОльшую гибкость компонента.
Например, в зависимости от переданной функции, компонент списка может отрисовывать
разные списки, а функции, получающие данные, будут описаны у родителя.

1.1 Render-функция. В компонент а качестве аргумента передаётся функция, которая содержит 
JSX код отрисовки части, или всего компонента. Таким образом можно гибко переиспользовать
логику компонента но менять его отображение сверху. 

2. Передача компонентов. Компоненты React также можно передавать в качестве аргументов. Таким
образом можно создвавть служебный компоненты-контейнеры, отвечающие за взаимное расположение
и CSS разметку нескольких компонентов, которые они получают в качестве аргументов. По такому же принципу строятся Error Boundry.

3. Children. React.Children имеет ряд полезных функций. Например, map применяет коллбэк-функцию ко всем children элемента, независимо от того, что они из себя представляют. Таким образом можно управлять отображением элементов: изменять, заменять их, скрывать, выбирать варианты... Изменять созданный компонент нельзя, поэтому применяется метод React.cloneElement(elem, {props}); и во вновь созданную копию элемента добавляются свойства из props.

4. Компоненты высшего порядка (HOC). Это, по сути, реализация паттерна "декоратор". Функционал компонента делится на части (например, логика и отображение) исходя из возможности переиспользовать части (например, любой сетевой компонент запрашивает данные, и пока не получит, ставит лоадер, при получении рендерит их, при ошибке рендерит сообщение об ошибке). Далее такой полу-компонент оборачивается в функцию, которая его возвращает. Эта функция принимает в качестве аргумента компонент, который будет рендерить, другие функции и параметры (например, компонент для рендеринга, и функцию запроса данных). Внутри такого компонента доступны props, переданные по вызову переменной, которой присвоена функция, через замыкание. Таких обёрток может быть сколько угодно, каждая добавляет свой функционал и аспекты логики.

--Context--

const { Provider, Consumer } = React.createContext(); создаёт пару компонентов, которые используются для передачи значения дочерним компонентам, не "прошивая" props промежуточных компонентов.
<Provider value={value}></Provider> оборачивает компоненты, которым будет доступен value. В месте, где нужно получить value, строится такая конструкция:
<Consumer>
	(value) => {return(компонент, использующий value)}
</Consumer>
Вместо такой конструкции удобно использовать HOC, обворачивающий компонент.



